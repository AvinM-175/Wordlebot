---
phase: 15-content-js-wiring-background-update-check
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dictionary.js
  - src/content.js
autonomous: true

must_haves:
  truths:
    - "Suggestions appear immediately from cache on every page load — no perceptible delay from the background check"
    - "When the bundle URL is the same but the content fingerprint differs, the extension detects the mismatch in background and re-renders suggestions using the updated dictionary"
    - "The browser console shows a log entry indicating whether a re-extraction was triggered by URL change or fingerprint mismatch, distinguishing it from timer-based fallback"
  artifacts:
    - path: "src/dictionary.js"
      provides: "checkForUpdate async function + export"
      contains: "checkForUpdate"
      exports: ["window.WordleBot.checkForUpdate"]
    - path: "src/content.js"
      provides: "Fire-and-forget background check call in backgroundInit"
      contains: "checkForUpdate"
  key_links:
    - from: "src/content.js"
      to: "src/dictionary.js"
      via: "window.WordleBot.checkForUpdate(loadResult.dictResult)"
      pattern: "WordleBot\\.checkForUpdate"
    - from: "src/content.js"
      to: "src/content.js"
      via: "clearCaches then loadDictionaryAndCaches(true) then processBoardState on background update"
      pattern: "loadDictionaryAndCaches\\(true\\)"
    - from: "src/dictionary.js"
      to: "src/dictionary.js"
      via: "checkForUpdate calls tryExtractionWithRetry, computeFingerprint, saveToCache"
      pattern: "tryExtractionWithRetry|computeFingerprint|saveToCache"
---

<objective>
Wire the non-blocking background update check into the extension so that after serving cached suggestions immediately, the extension silently re-extracts the dictionary if the content fingerprint changed, then rebuilds caches and re-renders suggestions.

Purpose: Complete the stale-while-revalidate pattern — Phase 14 built the URL pre-check infrastructure, Phase 15 adds the background content verification that catches same-URL dictionary changes.
Output: Two modified files (dictionary.js with checkForUpdate, content.js with fire-and-forget call), covering DICT-02, DICT-03, DICT-05, DICT-06.
</objective>

<execution_context>
@C:/Users/avinm/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/avinm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@C:/WordleBot/.planning/PROJECT.md
@C:/WordleBot/.planning/ROADMAP.md
@C:/WordleBot/.planning/STATE.md
@C:/WordleBot/.planning/phases/14-dictionary-change-detection/14-01-SUMMARY.md
@C:/WordleBot/.planning/phases/15-content-js-wiring-background-update-check/15-RESEARCH.md
@C:/WordleBot/src/dictionary.js
@C:/WordleBot/src/content.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkForUpdate function to dictionary.js</name>
  <files>src/dictionary.js</files>
  <action>
Add an async function `checkForUpdate(cachedResult)` inside the dictionary.js IIFE, placed after `tryExtractionWithRetry()` and before `loadDictionary()` (approximately after line 140).

The function:
1. Calls `tryExtractionWithRetry()` — returns `{ words, bundleUrl }` or null
2. If null (extraction failed), logs `[WordleBot] Background check: extraction failed, keeping cached dictionary` and returns null
3. Calls `computeFingerprint(extractionResult.words)` — MUST use `.words` property, NOT the whole object (Pitfall 4 from research)
4. Compares fingerprint against `cachedResult.fingerprint` — if equal, logs `[WordleBot] Background check: fingerprint match, dictionary unchanged` and returns null
5. On mismatch, builds a new DictionaryResult object: `{ words: extractionResult.words, source: 'extracted', freshness: 'fresh', fingerprint: fp, bundleUrl: extractionResult.bundleUrl }`
6. Calls `getBundledFingerprint()` then `saveToCache(newResult, bundledFp)` to persist the updated dictionary
7. Logs `[WordleBot] Background check: fingerprint mismatch -- dictionary updated (XXXXXXXX -> YYYYYYYY)` using first 8 chars of old and new fingerprints
8. Returns the new DictionaryResult

Export the function at the bottom of the IIFE alongside the existing export:
```javascript
window.WordleBot.checkForUpdate = checkForUpdate;
```

Use ES5 style (`var`, no arrow functions) per codebase conventions. Use `async function` (dictionary.js already uses async/await internally — see computeFingerprint, loadFromCache, saveToCache, loadDictionary).

Add a JSDoc comment matching the existing style in dictionary.js (see loadDictionary and loadFromCache for examples).
  </action>
  <verify>
Open src/dictionary.js and confirm:
1. `checkForUpdate` function exists between `tryExtractionWithRetry` and `loadDictionary`
2. Uses `extractionResult.words` (not bare `extractionResult`) for `computeFingerprint`
3. Calls `saveToCache` with bundled fingerprint on mismatch
4. Export line `window.WordleBot.checkForUpdate = checkForUpdate` exists near `window.WordleBot.loadDictionary = loadDictionary`
5. No syntax errors: run `node --check src/dictionary.js` (will fail due to chrome/window globals but should NOT show syntax errors — look for SyntaxError specifically)
  </verify>
  <done>
`checkForUpdate` is defined, correctly uses `extractionResult.words` for fingerprinting, persists via `saveToCache`, logs fingerprint mismatch with old/new hashes, and is exported on `window.WordleBot`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire fire-and-forget background check into content.js backgroundInit</name>
  <files>src/content.js</files>
  <action>
In content.js `backgroundInit()`, add the fire-and-forget background check AFTER the `showSourceIndicator(loadResult.dictResult)` call (line 245) and BEFORE the `waitForBoard()` call (line 340). This placement ensures:
- Dictionary and caches are loaded (loadResult available)
- Source indicator is shown
- Background check runs in parallel with board detection (non-blocking)

Add this block:

```javascript
// DICT-05: Non-blocking background update check (only when dictionary came from cache)
if (loadResult.dictResult.source === 'cached') {
  window.WordleBot.checkForUpdate(loadResult.dictResult).then(function(newResult) {
    if (!newResult) return;
    // DICT-06: Fingerprint mismatch detected -- rebuild and re-render
    console.log('[WordleBot] Background update: rebuilding caches and re-rendering suggestions');
    clearCaches().then(function() {
      return loadDictionaryAndCaches(true);
    }).then(function(reloadResult) {
      showSourceIndicator(reloadResult.dictResult);
      var currentState = window.WordleBot.readBoardState();
      if (currentState && !isComputing) {
        processBoardState(currentState, false);
      }
    }).catch(function(err) {
      console.warn('[WordleBot] Background rebuild failed: ' + err.message);
    });
  }).catch(function(err) {
    console.warn('[WordleBot] Background update check failed: ' + err.message);
  });
}
```

Critical details:
- Source guard: ONLY call when `source === 'cached'` — never on 'extracted' or 'bundled' (Pitfall 1, Pitfall 2)
- Fire-and-forget: Use `.then()` chain, do NOT `await` — the pipeline must continue to `waitForBoard()` immediately (DICT-05)
- `loadDictionaryAndCaches(true)` — MUST pass `true` for forceRebuild (Pitfall 6)
- `isComputing` guard before `processBoardState` — prevents race with initial compute (Pitfall 3)
- `processBoardState(currentState, false)` — use `false` for isInitial so the fade-in animation signals a refresh
- Use `.then()` chains (not async/await) per ES5 convention for the fire-and-forget call. The surrounding `backgroundInit` uses async/await, but the fire-and-forget branch should use `.then()` to make the non-blocking intent visually clear.

NOTE: `processBoardState` is defined inside `backgroundInit` (line 248 of current content.js) so it IS in scope for this code. Same for `isComputing` (line 40), `clearCaches` (line 55), `loadDictionaryAndCaches` (line 154), and `showSourceIndicator` (line 98).
  </action>
  <verify>
Open src/content.js and confirm:
1. The `if (loadResult.dictResult.source === 'cached')` block exists after `showSourceIndicator` and before `waitForBoard()`
2. Uses `.then()` chain (not await) for the background check
3. Passes `true` to `loadDictionaryAndCaches` in the rebuild path
4. Has `isComputing` guard before `processBoardState`
5. Has `.catch()` handlers on both the outer checkForUpdate promise and the inner rebuild chain
6. No syntax errors: run `node --check src/content.js` (look for SyntaxError specifically)
  </verify>
  <done>
Fire-and-forget background check is wired: gated on `source === 'cached'`, calls `checkForUpdate` via `.then()`, rebuilds caches and re-renders suggestions on fingerprint mismatch, with proper error handling and `isComputing` guard.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `src/dictionary.js` exports `checkForUpdate` — grep for `window.WordleBot.checkForUpdate`
2. `src/content.js` calls `checkForUpdate` only when source is cached — grep for `source === 'cached'`
3. No `await` before `checkForUpdate` in content.js — the call must be fire-and-forget
4. `loadDictionaryAndCaches(true)` appears in the background rebuild path (not `false`)
5. Console log taxonomy is complete: "Background check: fingerprint match" and "Background check: fingerprint mismatch" in dictionary.js, "Background update: rebuilding caches" in content.js
</verification>

<success_criteria>
- checkForUpdate function exists in dictionary.js, correctly fingerprints extracted words, persists on mismatch, and is exported
- content.js calls checkForUpdate as fire-and-forget (non-blocking) only when dictionary source is 'cached'
- Background rebuild path uses clearCaches + loadDictionaryAndCaches(true) + processBoardState with isComputing guard
- DICT-02, DICT-03, DICT-05, DICT-06 requirements are covered
- No syntax errors in either file
</success_criteria>

<output>
After completion, create `.planning/phases/15-content-js-wiring-background-update-check/15-01-SUMMARY.md`
</output>
