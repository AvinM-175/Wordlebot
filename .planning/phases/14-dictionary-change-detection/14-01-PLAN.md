---
phase: 14-dictionary-change-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/dictExtractor.js
  - src/dictionary.js
autonomous: true

must_haves:
  truths:
    - "After extraction, the wordlebot_dict cache entry contains a bundleUrl field with the NYT bundle URL string"
    - "On page load with a fresh cache whose bundleUrl matches the current bundle URL, cached words are returned immediately and no extraction runs"
    - "When bundleUrl cannot be determined (null), the 30-day staleness timer is used as the fallback — existing behavior unchanged"
    - "Pre-Phase-14 cache entries (no bundleUrl field) fall through to the 30-day timer without forced extraction"
    - "forceRefresh path still stores bundleUrl in the new cache entry after extraction completes"
  artifacts:
    - path: "src/dictExtractor.js"
      provides: "findBundleUrl exported as public API"
      contains: "findBundleUrl: findBundleUrl"
    - path: "src/dictionary.js"
      provides: "URL pre-check in loadFromCache, bundleUrl storage in saveToCache, findBundleUrl call in loadDictionary"
      contains: "bundleUrl"
  key_links:
    - from: "src/dictionary.js (loadDictionary)"
      to: "window.WordleBot.dictExtractor.findBundleUrl"
      via: "function call before loadFromCache"
      pattern: "dictExtractor\\.findBundleUrl"
    - from: "src/dictionary.js (loadFromCache)"
      to: "cacheData.bundleUrl"
      via: "URL equality comparison"
      pattern: "cacheData\\.bundleUrl.*currentBundleUrl"
    - from: "src/dictionary.js (saveToCache)"
      to: "dictResult.bundleUrl"
      via: "field inclusion in cache entry"
      pattern: "bundleUrl.*dictResult\\.bundleUrl"
---

<objective>
Add bundle URL storage and O(1) URL pre-check to the dictionary cache system.

Purpose: Enable the extension to detect NYT dictionary changes from cache alone — before any extraction occurs — by comparing stored bundle URLs. This replaces the 30-day timer as the primary staleness signal while keeping it as a fallback.

Output: Modified `dictExtractor.js` (export findBundleUrl) and `dictionary.js` (URL pre-check in loadFromCache, bundleUrl in saveToCache, findBundleUrl call in loadDictionary).
</objective>

<execution_context>
@C:/Users/avinm/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/avinm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-dictionary-change-detection/14-RESEARCH.md
@src/dictionary.js
@src/dictExtractor.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Export findBundleUrl and plumb bundleUrl through extraction result in dictionary.js</name>
  <files>src/dictExtractor.js, src/dictionary.js</files>
  <action>
**dictExtractor.js — Export findBundleUrl (1 change):**

At the bottom of the IIFE (currently lines 472-475), add `findBundleUrl` to the exported object:

```javascript
window.WordleBot.dictExtractor = {
  extract: extract,
  findBundleUrl: findBundleUrl
};
```

No changes to the `findBundleUrl()` function body itself.

**dictionary.js — Plumb bundleUrl through tryExtraction (1 change):**

Currently `tryExtraction()` (lines 107-123) calls `dictExtractor.extract()` but only returns `result.allWords`, discarding `bundleUrl`. Change it to return an object with both:

```javascript
async function tryExtraction() {
  try {
    if (!window.WordleBot.dictExtractor || !window.WordleBot.dictExtractor.extract) {
      console.warn('[WordleBot] dictExtractor not available');
      return null;
    }
    var result = await window.WordleBot.dictExtractor.extract();
    if (result.success && result.allWords && result.allWords.length > 0) {
      return { words: result.allWords, bundleUrl: result.bundleUrl || null };
    }
    console.warn('[WordleBot] Extraction returned failure: ' + (result.error || 'unknown'));
    return null;
  } catch (e) {
    console.warn('[WordleBot] Extraction threw error: ' + e.message);
    return null;
  }
}
```

**dictionary.js — Update tryExtractionWithRetry callers in loadDictionary (Step C):**

Currently `loadDictionary()` line 245 does `var extractedWords = await tryExtractionWithRetry()` and later uses `extractedWords` as an array. After the `tryExtraction` change, this returns `{ words, bundleUrl }` or null. Update the usage in `loadDictionary()`:

Change the extraction handling block (lines 245-267) to:

```javascript
// Step C: Try live extraction with retry
var extractionResult = await tryExtractionWithRetry();

if (extractionResult) {
  var fp = await computeFingerprint(extractionResult.words);
  var result = {
    words: extractionResult.words,
    source: 'extracted',
    freshness: 'fresh',
    fingerprint: fp,
    bundleUrl: extractionResult.bundleUrl
  };

  console.log('[WordleBot] Dictionary extracted (' +
    result.words.length + ' words, fingerprint: ' +
    fp.substring(0, 8) + ')');

  // Save to cache for next load
  await saveToCache(result, bundledFp);

  window.WordleBot.dictionaryFingerprint = result.fingerprint;

  return result;
}
```

Note: `tryExtractionWithRetry` delegates to `tryExtraction` — no changes needed to `tryExtractionWithRetry` itself since it passes through the return value.
  </action>
  <verify>
1. In dictExtractor.js, confirm the export block includes both `extract` and `findBundleUrl`.
2. In dictionary.js, confirm `tryExtraction()` returns `{ words, bundleUrl }` on success and `null` on failure.
3. In dictionary.js, confirm `loadDictionary()` Step C uses `extractionResult.words` and `extractionResult.bundleUrl`.
4. Search for any remaining references to `extractedWords` in dictionary.js — there should be none.
  </verify>
  <done>dictExtractor exports findBundleUrl. tryExtraction returns bundleUrl alongside words. loadDictionary plumbs bundleUrl through to saveToCache.</done>
</task>

<task type="auto">
  <name>Task 2: Add bundleUrl to saveToCache, URL pre-check to loadFromCache, and findBundleUrl call to loadDictionary</name>
  <files>src/dictionary.js</files>
  <action>
**saveToCache — Store bundleUrl (lines 198-216):**

Add `bundleUrl` to the cache entry object. Change the entry construction to:

```javascript
var entry = {
  words: dictResult.words,
  fingerprint: dictResult.fingerprint,
  extractedAt: Date.now(),
  bundledFingerprint: bundledFp,
  source: dictResult.source,
  bundleUrl: dictResult.bundleUrl || null
};
```

The `dictResult.bundleUrl` comes from the extraction result plumbed in Task 1. When source is `bundled`, `bundleUrl` will be `null` — correct behavior per research anti-pattern "Storing bundleUrl on bundled fallback."

**loadFromCache — Add currentBundleUrl parameter and URL pre-check (lines 150-190):**

1. Change the function signature to accept a second parameter: `async function loadFromCache(currentBundledFp, currentBundleUrl)`

2. After the bundled fingerprint check (line 163) and BEFORE the 30-day staleness check (line 165), insert the URL pre-check block:

```javascript
// Bundle URL pre-check (O(1) staleness signal) — DICT-01/DICT-04
if (currentBundleUrl !== null && cacheData.bundleUrl) {
  if (cacheData.bundleUrl !== currentBundleUrl) {
    console.log('[WordleBot] Bundle URL changed -- cache invalidated (new bundle: ' +
      currentBundleUrl.split('/').pop() + ')');
    return null;  // force extraction
  }
  // URL match: cache is definitively fresh — skip 30-day check
  var freshResult = {
    words: cacheData.words,
    source: 'cached',
    freshness: 'fresh',
    fingerprint: cacheData.fingerprint
  };
  console.log('[WordleBot] Dictionary loaded from cache (' +
    freshResult.words.length + ' words, URL match, fingerprint: ' +
    freshResult.fingerprint.substring(0, 8) + ')');
  return freshResult;
}

// FALLBACK: No URL available (null currentBundleUrl or missing cacheData.bundleUrl)
// Use 30-day timer (DICT-07)
```

CRITICAL: The guard `currentBundleUrl !== null && cacheData.bundleUrl` ensures:
- If `findBundleUrl()` returned null → falls through to 30-day timer
- If cache entry is pre-Phase-14 (no `bundleUrl` field) → falls through to 30-day timer
- Only when BOTH are non-null does URL comparison run

**loadDictionary — Call findBundleUrl before loadFromCache (lines 224-295):**

After Step A (bundledFp, line 228) and before Step B (cache fast path, line 231), insert Step A2:

```javascript
// Step A2: Discover current bundle URL for pre-check (DICT-01)
var currentBundleUrl = null;
if (window.WordleBot.dictExtractor && window.WordleBot.dictExtractor.findBundleUrl) {
  try {
    var urlResult = window.WordleBot.dictExtractor.findBundleUrl();
    // findBundleUrl may return a Promise (async for Strategies 2-4)
    if (urlResult && typeof urlResult.then === 'function') {
      urlResult = await urlResult;
    }
    // Normalize: string | string[] | null → string | null
    if (typeof urlResult === 'string') {
      currentBundleUrl = urlResult;
    } else if (Array.isArray(urlResult) && urlResult.length > 0) {
      currentBundleUrl = urlResult[0];
    }
  } catch (e) {
    console.warn('[WordleBot] findBundleUrl() pre-check failed: ' + e.message);
  }
}
```

Then update the `loadFromCache` call on line 232 to pass the URL:

```javascript
var cached = await loadFromCache(bundledFp, currentBundleUrl);
```

Note: `findBundleUrl()` is called regardless of `forceRefresh`. When `forceRefresh=true`, Step B is skipped entirely (the `if (!forceRefresh)` guard), so `currentBundleUrl` is computed but not used for comparison. The URL still flows through `extractionResult.bundleUrl` into `saveToCache` via the extraction path (Task 1), so forceRefresh correctly stores the new URL.

Also update the JSDoc comment for `loadFromCache` to document the new parameter.
  </action>
  <verify>
1. `saveToCache`: Confirm the cache entry object includes `bundleUrl: dictResult.bundleUrl || null`.
2. `loadFromCache`: Confirm it accepts `currentBundleUrl` parameter. Confirm the URL pre-check block exists AFTER the bundled fingerprint check and BEFORE the 30-day staleness check. Confirm the guard is `currentBundleUrl !== null && cacheData.bundleUrl` (both must be truthy).
3. `loadDictionary`: Confirm `findBundleUrl()` is called between Step A and Step B. Confirm the result is normalized (string/array/null → string/null). Confirm `loadFromCache(bundledFp, currentBundleUrl)` passes both arguments.
4. Verify no console errors by searching for syntax issues: all `var` declarations present, all braces balanced, no stray semicolons.
  </verify>
  <done>
Cache entry stores bundleUrl after extraction. loadFromCache performs URL pre-check: URL match returns fresh immediately (DICT-04), URL mismatch forces extraction, null URL falls through to 30-day timer (DICT-07). loadDictionary calls findBundleUrl before cache lookup.
  </done>
</task>

</tasks>

<verification>
All three Phase 14 success criteria verified via console output on a live NYT Wordle page:

1. **bundleUrl stored after extraction:** Open DevTools → Application → Chrome Storage → Local → `wordlebot_dict`. Confirm the entry includes a `bundleUrl` field with a URL string like `https://www.nytimes.com/games-assets/v2/wordle.HASH.js`.

2. **URL match serves cache without extraction:** Reload the page. Console should show `[WordleBot] Dictionary loaded from cache (N words, URL match, fingerprint: XXXXXXXX)`. Console should NOT show `[WordleBot] Dictionary extracted`. This confirms DICT-04.

3. **30-day fallback when no URL:** If `findBundleUrl()` were to return null (can be simulated by temporarily returning null from the function), the console should show the standard staleness-based cache log (no "URL match" message). The 30-day timer logic runs as before. This confirms DICT-07.

4. **Pre-Phase-14 cache migration:** Clear the `bundleUrl` field from a stored cache entry (DevTools → edit the storage value). Reload. Console should show the standard 30-day-based cache log, NOT "Bundle URL changed". The system self-heals on next extraction.

5. **forceRefresh path:** Shift+Click the extension's refresh action. After extraction completes, check storage — `bundleUrl` should be populated in the new cache entry.
</verification>

<success_criteria>
- `wordlebot_dict` cache entry includes `bundleUrl` after every successful extraction
- Page reload with matching URL: no extraction, immediate cache serve
- Page reload with mismatched URL: extraction triggered
- Page reload with null URL (either side): 30-day timer used
- `findBundleUrl` is exported from `window.WordleBot.dictExtractor`
- No other files modified (content.js wiring is Phase 15)
</success_criteria>

<output>
After completion, create `.planning/phases/14-dictionary-change-detection/14-01-SUMMARY.md`
</output>
