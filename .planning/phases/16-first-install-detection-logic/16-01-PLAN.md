---
phase: 16-first-install-detection-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/content.js
autonomous: true
requirements:
  - ONBD-01
  - ONBD-02

must_haves:
  truths:
    - "A fresh install (no WordleBot storage keys) produces isFirstInstall === true"
    - "A pre-v1.7 user (wordlebot_dict or wordlebot_cache present, no wordlebot_onboarded) produces isFirstInstall === false"
    - "A post-v1.7 user (wordlebot_onboarded === true) produces isFirstInstall === false"
    - "Pre-v1.7 existing users get wordlebot_onboarded=true written (normalization)"
    - "Detection does not delay dictionary loading or suggestion rendering"
    - "Storage read failure defaults to isFirstInstall === false (safe fallback)"
  artifacts:
    - path: "src/content.js"
      provides: "detectFirstInstall function and detection block in loadDictionaryAndCaches"
      contains: "function detectFirstInstall"
  key_links:
    - from: "src/content.js detectFirstInstall()"
      to: "window.WordleBot.isFirstInstall"
      via: "assignment in loadDictionaryAndCaches before loadDictionary call"
      pattern: "window\\.WordleBot\\.isFirstInstall.*=.*detectFirstInstall"
    - from: "src/content.js loadDictionaryAndCaches"
      to: "chrome.storage.local.get"
      via: "multi-key read of detection keys before loadDictionary"
      pattern: "chrome\\.storage\\.local\\.get\\(\\[.*wordlebot_onboarded"
---

<objective>
Add first-install detection logic to content.js so the extension can distinguish genuine first-time installers from existing users upgrading to v1.7.

Purpose: Phase 17 (onboarding UI) needs a reliable `window.WordleBot.isFirstInstall` boolean to decide whether to show the onboarding overlay. This plan produces that boolean with zero UI changes.

Output: Modified `src/content.js` with `detectFirstInstall()` helper and detection block at the top of `loadDictionaryAndCaches()`.
</objective>

<execution_context>
@C:/Users/avinm/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/avinm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-first-install-detection-logic/16-CONTEXT.md
@.planning/phases/16-first-install-detection-logic/16-RESEARCH.md
@src/content.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detectFirstInstall helper and initialize namespace property</name>
  <files>src/content.js</files>
  <action>
Two changes to content.js:

1. **Initialize namespace property** (line 2 area, alongside existing `window.WordleBot.lastSuggestions = null`):
   Add `window.WordleBot.isFirstInstall = null;` — null means "not yet determined." Phase 17 should check `=== true`, so null correctly maps to "don't show onboarding yet."

2. **Add detectFirstInstall function** above `loadDictionaryAndCaches` (around line 153 area):

```javascript
/**
 * Determine if the current user is a first-time installer.
 * Three-state heuristic (from CONTEXT.md locked decisions):
 *   - wordlebot_onboarded === true -> post-v1.7 user (false)
 *   - wordlebot_dict OR wordlebot_cache present -> pre-v1.7 existing user (false)
 *   - all absent -> genuine first install (true)
 * Storage read failure: caller passes {} -> returns false (safe default)
 * @param {Object} stored - Result of chrome.storage.local.get([...])
 * @returns {boolean}
 */
function detectFirstInstall(stored) {
  if (stored.wordlebot_onboarded === true) {
    return false;
  }
  if (stored.wordlebot_dict || stored.wordlebot_cache) {
    return false;
  }
  return true;
}
```

Use ES5 style (var, function declaration) per codebase conventions. No arrow functions.
  </action>
  <verify>
Open src/content.js and confirm:
- `window.WordleBot.isFirstInstall = null;` exists near line 2-3
- `function detectFirstInstall(stored)` exists above `loadDictionaryAndCaches`
- Function uses strict equality `=== true` for wordlebot_onboarded check
- Function returns boolean (true for first install, false otherwise)
  </verify>
  <done>detectFirstInstall helper exists in content.js. window.WordleBot.isFirstInstall initialized to null at module level.</done>
</task>

<task type="auto">
  <name>Task 2: Wire detection into loadDictionaryAndCaches with pre-loadDictionary storage read</name>
  <files>src/content.js</files>
  <action>
Modify `loadDictionaryAndCaches(forceRebuild)` to add first-install detection at the TOP of the function, BEFORE the `loadDictionary` call. This ordering is critical (Pitfall 4 from research): loadDictionary can write wordlebot_dict during extraction, so detection must read storage before that happens.

Insert at the very beginning of `loadDictionaryAndCaches`, before the existing `var dictResult = await window.WordleBot.loadDictionary(forceRebuild);` line:

```javascript
  // Phase 16: Read detection keys BEFORE loadDictionary can write wordlebot_dict
  var detectionStored;
  try {
    detectionStored = await chrome.storage.local.get(['wordlebot_dict', 'wordlebot_cache', 'wordlebot_onboarded']);
  } catch (e) {
    detectionStored = {};
  }
  window.WordleBot.isFirstInstall = detectFirstInstall(detectionStored);

  // Normalize pre-v1.7 existing users to post-v1.7 state (fire-and-forget)
  if (!window.WordleBot.isFirstInstall && detectionStored.wordlebot_onboarded !== true) {
    chrome.storage.local.set({ wordlebot_onboarded: true }).catch(function(err) {
      console.warn('[WordleBot] Failed to write onboarded flag: ' + err.message);
    });
  }
```

IMPORTANT constraints:
- Do NOT modify the existing `var cached = await chrome.storage.local.get('wordlebot_cache');` on line 173 — that read stays separate for the computational cache check. The detection read is a DIFFERENT read that happens earlier for a different purpose.
- Do NOT add console logging for the detection result (locked decision: keep console clean).
- Do NOT touch clearCaches() — wordlebot_onboarded is already excluded (clearCaches only removes wordlebot_cache and wordlebot_dict).
- Use `var` (not let/const) per ES5 conventions.
- The normalization write uses `.catch()` for fire-and-forget error handling — do not await it.
  </action>
  <verify>
1. Read src/content.js and confirm detection block appears at the top of loadDictionaryAndCaches, before the loadDictionary call.
2. Confirm the existing `var cached = await chrome.storage.local.get('wordlebot_cache')` line is unchanged.
3. Confirm clearCaches() still only removes ['wordlebot_cache', 'wordlebot_dict'] — wordlebot_onboarded is NOT listed.
4. Verify no console.log statements were added for detection result.
5. Trace the three scenarios mentally:
   - Fresh install: all three keys absent -> detectionStored = {wordlebot_dict: undefined, ...} -> detectFirstInstall returns true -> no normalization write
   - Pre-v1.7 user: wordlebot_dict present, wordlebot_onboarded absent -> returns false -> normalization writes wordlebot_onboarded=true
   - Post-v1.7 user: wordlebot_onboarded === true -> returns false -> no normalization write (already normalized)
6. Verify Shift+Refresh path: clearCaches removes dict+cache but NOT onboarded -> detection re-runs -> wordlebot_onboarded still true -> isFirstInstall=false (correct)
  </verify>
  <done>
Detection block is wired into loadDictionaryAndCaches before loadDictionary. window.WordleBot.isFirstInstall is set to true for fresh installs, false for existing users. Pre-v1.7 users are normalized with wordlebot_onboarded=true. Existing cache read logic is unchanged. No console logging added for detection.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full detection contract:

1. **Code structure check:** `detectFirstInstall` function exists above `loadDictionaryAndCaches`. Detection block is the first thing inside `loadDictionaryAndCaches`, before `loadDictionary` call.

2. **Namespace initialization:** `window.WordleBot.isFirstInstall = null` at top of content.js alongside `window.WordleBot.lastSuggestions = null`.

3. **No regressions:** The existing `var cached = await chrome.storage.local.get('wordlebot_cache')` computational cache read (line ~173 area) is untouched. clearCaches() still removes only `['wordlebot_cache', 'wordlebot_dict']`.

4. **Three-state correctness:**
   - Fresh install (no keys) -> isFirstInstall = true, no write
   - Pre-v1.7 (has dict/cache, no onboarded) -> isFirstInstall = false, writes onboarded=true
   - Post-v1.7 (onboarded=true) -> isFirstInstall = false, no write

5. **Edge cases:**
   - Storage read failure -> detectionStored = {} -> detectFirstInstall({}) returns true... wait, that would be incorrect. Actually: `{}.wordlebot_onboarded === true` is false, `{}.wordlebot_dict` is undefined (falsy), `{}.wordlebot_cache` is undefined (falsy) -> returns true. But the locked decision says "Storage read failure = fallback to existing user (safe default)."

   CORRECTION: The try/catch must handle this. If the storage read fails, we need isFirstInstall = false, not true. The research code example uses `detectionStored = {}` as fallback, which would produce `true` from `detectFirstInstall({})`. This is a bug in the research example. The correct fallback after catch is to set `window.WordleBot.isFirstInstall = false` directly and skip the detectFirstInstall call, OR use a sentinel value in detectionStored. The simplest fix: after the catch, set `window.WordleBot.isFirstInstall = false; return;`... but that would skip the entire function.

   Better approach: In the catch block, set `detectionStored = null;` and check before calling detectFirstInstall:
   ```javascript
   if (detectionStored === null) {
     window.WordleBot.isFirstInstall = false;
   } else {
     window.WordleBot.isFirstInstall = detectFirstInstall(detectionStored);
   }
   ```
   OR simpler: keep `detectionStored = {};` in catch and add a special case at the top of detectFirstInstall that handles "all absent = first install" only when storage read succeeded. Simplest: just set isFirstInstall = false directly in the catch:

   ```javascript
   var detectionStored;
   try {
     detectionStored = await chrome.storage.local.get(['wordlebot_dict', 'wordlebot_cache', 'wordlebot_onboarded']);
   } catch (e) {
     detectionStored = null;
   }
   window.WordleBot.isFirstInstall = detectionStored ? detectFirstInstall(detectionStored) : false;
   ```

   The executor MUST use this pattern (detectionStored = null on failure, ternary for isFirstInstall assignment) to satisfy the locked decision that storage read failure = existing user.
</verification>

<success_criteria>
1. `window.WordleBot.isFirstInstall` is `null` before loadDictionaryAndCaches runs, then `true` or `false` after.
2. Fresh install (no storage) -> `isFirstInstall === true`.
3. Pre-v1.7 user (wordlebot_dict or wordlebot_cache present) -> `isFirstInstall === false`, wordlebot_onboarded written as true.
4. Post-v1.7 user (wordlebot_onboarded === true) -> `isFirstInstall === false`, no write.
5. Storage read failure -> `isFirstInstall === false` (safe default).
6. No delay to dictionary loading or suggestion rendering (detection is a single storage read at function start).
7. clearCaches() does NOT remove wordlebot_onboarded.
8. No console logging for detection result.
</success_criteria>

<output>
After completion, create `.planning/phases/16-first-install-detection-logic/16-01-SUMMARY.md`
</output>
